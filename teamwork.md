# Teamwork Reflection
Despite being together for 9 weeks at this stage, we found this iteration to be more challenging than the second iteration. This was because of the subjectiveness of this iterations requirements. As in, instead of implementing to a specification, most of the work revolved around refactoring, which was subjective and varied from person to person. As a result, we found ourselves communicating a lot more intensively and doing a lot more of the work together, as everyone appeared to have different tastes when it came to refactoring. Additionally, as refactoring involved some minor structural changes, these were communicated very clearly as our previous code was rather rigid and such changes could break other functions. It was important that these were isolated and changes were made in unison as to ensure that the application remained functional at all times. As with previous iterations, we tried to centre around the fundamental principles of *AGILE*, which involved frequent and functional interactions. We ran our *pytests* after each change to ensure that they were still working correctly.


## How often you met, and why you met that often
As was the case with previous iterations, we met synchronously twice a week, once during the tutorial in person, where a standup was held with our tutor, and another time on Saturday via VoIP call / TeamViewer. Outside of this, asynchronous communications were made via Facebook messenger messages, task board updates and also group chat messages. We met this often because of time limitations and other commitments, making it difficult to sync up the schedules of 4 different people. We found these to be the only times we were all available to meet. We did most of our work during our Saturday meetups, as we were able to engage in pair coding, virtual standups and reviews of our progress. Towards the due date, we met more often and conducted longer Saturday conferences. Outside of whole team meetings, we also met as pairs more often to conduct pair coding, peer reviews and other various discussions of our plans and progression. 

## What methods you used to ensure that meetings were successful
Similar to previous iterations, we always set out an agenda at the start of our Saturday meetings, where we started by having every team member contribute what they have done, what challenges they faced, what they will be doing and their general thoughts on the project. In doing so, we addressed everyone?s concerned. We also referenced the task board and verified our progress by running the front end on a shared video screen, and simulating user stories. By verifying our progress against specifications and unit tests, we were able to confirm our progress to the whole team and ensure everyone was satisfied with the work being completed.

## What steps you took when things did not go to plan during iteration 3
Nothing terribly wrong happened during this iteration. The plan was rather flexible and was changed continuously. As we had adopted the **AGILE** development practices, we always had a working product. The challenge we faced in this iteration was coming to agreement on how to refactor and what changes were to be made. When this happened, we tried to come to a unanimous verdict, but if this was not possible, we negotiated within the team to come to a democratic agreement. We had a few instances where during refactoring, we broke functionality of our program. This was a large issue and we had overcome this, by rolling it back essentially, by checking out the file on Git. We would then start again, being careful of the changes we made and ensuring that the structure/interface remained the same.

## Details on how you had multiple people working on the same code
As was the case with previous iterations, this was never really an issue, since we were using Git and we were mostly working on different branches. Therefore our work was completely separate of one another and the only time we had issues was when we were merging the work back together. We only had one instances where two of us had accidently written the same users/all function, wasting a bit of time, but apart from that we all worked on the functions and modules we had assigned ourselves. As the server was already created, we rarely had multiple people working on the same code independently. When we did work to refactor the same code, we mostly did this through pair coding, which wasn't an issue as we were discussing our changes live.

## Consistent work towards the goal of a working backend.
We had a working backend already as of iteration 2. The only real implementation changes made to the back end were the addition of the extra functions and updates to the specification. This was easily done, so from the start, we had a working backend that worked in conjunction with the frontend. To ensure this remained the case, we adopted the *AGILE* practice of always ensuring that a working sprint existed at all times. As more and more refactoring changes were completed, we kept running our unit tests from the previous iteration, updated to the new specification, to ensure that the backend was always working. 

## Task board is always up to date and reflects ongoing work
Once again, similar to previous iterations, we kept our task board up to date at all times by dragging and dropping issues to the appropriate sections. At the start of the iteration, we updated the task board with the new specification and what else needed to be completed in the backlog. This was then all moved to *to do*, assigned and then when worked on, moved to *in progress* and eventually *closed* when we were satisfied as a team that the issue was fully completed. By doing this, we ensured all requirements and tasks were addressed and completed. As was the case before, we also had the option of assigning and adding comments via the task board, but this was mostly done verbally.

## Demonstration of appropriate use of agile practices to work effectively as a team.
Evident through the Git commit history, we strived to follow agile practices as a team by pushing functioning products frequently and iteratively. We worked in a cyclic process, where we implemented changes and refactored our code bit by bit through every sprint and always maintained a working product, tested via the backend and frontend. We have previously committed other agile practices, such as the use of the taskboard, frequent standups and use of tools such as Git. Throughout the course of this whole project, we always valued effective communications and frequent working sprints, adhering to agile principles.

